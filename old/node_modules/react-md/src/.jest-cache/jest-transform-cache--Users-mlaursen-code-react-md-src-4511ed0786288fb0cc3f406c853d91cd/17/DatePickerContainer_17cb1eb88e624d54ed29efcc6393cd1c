/* istanbul ignore next */'use strict'; /* eslint-env jest*/
/* eslint-disable global-require,max-len */
jest.unmock('../DatePickerContainer');
jest.unmock('../DatePicker');

var /* istanbul ignore next */_react = require('react'); /* istanbul ignore next */var _react2 = _interopRequireDefault(_react);
var /* istanbul ignore next */_reactDom = require('react-dom');
var /* istanbul ignore next */_reactAddonsTestUtils = require('react-addons-test-utils');




var /* istanbul ignore next */_DatePickerContainer = require('../DatePickerContainer'); /* istanbul ignore next */var _DatePickerContainer2 = _interopRequireDefault(_DatePickerContainer);
var /* istanbul ignore next */_keyCodes = require('../../constants/keyCodes'); /* istanbul ignore next */function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

describe('DatePickerContainer', function () {
  it('merges className and style', function () {
    var style = { display: 'block' };
    var className = 'test';
    var pickerStyle = { background: 'black' };
    var pickerClassName = 'picker-test';
    var datePickerContainer = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)(
    /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, /* istanbul ignore next */{
      id: 'test',
      style: style,
      className: className,
      pickerStyle: pickerStyle,
      pickerClassName: pickerClassName,
      locales: 'en-US' }));



    datePickerContainer.setState({ isOpen: true });

    var datePickerContainerNode = /* istanbul ignore next */(0, _reactDom.findDOMNode)(datePickerContainer);
    expect(datePickerContainerNode.style.display).toBe(style.display);
    expect(datePickerContainerNode.className).toContain(className);
  });

  it('allows for null, a Date object or a formatted string as the value prop', function () {
    var DateTimeFormat = require('intl').DateTimeFormat;
    var stringValue = '3/17/2017';
    var container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)(
    /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, /* istanbul ignore next */{ id: 'test', value: stringValue, locales: 'en-US', DateTimeFormat: DateTimeFormat }));


    var textField = /* istanbul ignore next */(0, _reactAddonsTestUtils.findRenderedDOMComponentWithTag)(container, 'input');
    expect(textField.value).toBe(stringValue);

    var dateValue = new Date(2017, 2, 17);
    container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)(
    /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, /* istanbul ignore next */{ id: 'test', value: dateValue, locales: 'en-US', DateTimeFormat: DateTimeFormat }));


    textField = /* istanbul ignore next */(0, _reactAddonsTestUtils.findRenderedDOMComponentWithTag)(container, 'input');
    expect(textField.value).toBe(stringValue);

    container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)(
    /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, /* istanbul ignore next */{ id: 'test', value: null, locales: 'en-US', DateTimeFormat: DateTimeFormat }));


    textField = /* istanbul ignore next */(0, _reactAddonsTestUtils.findRenderedDOMComponentWithTag)(container, 'input');
    expect(textField.value).toBe('');
  });

  it('allows for null, a Date object or a formatted string as the defaultValue prop', function () {
    var DateTimeFormat = require('intl').DateTimeFormat;
    var stringValue = '3/17/2017';
    var container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)(
    /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, /* istanbul ignore next */{ id: 'test', defaultValue: stringValue, locales: 'en-US', DateTimeFormat: DateTimeFormat }));


    var textField = /* istanbul ignore next */(0, _reactAddonsTestUtils.findRenderedDOMComponentWithTag)(container, 'input');
    expect(textField.value).toBe(stringValue);

    var dateValue = new Date(2017, 2, 17);
    container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)(
    /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, /* istanbul ignore next */{ id: 'test', defaultValue: dateValue, locales: 'en-US', DateTimeFormat: DateTimeFormat }));


    textField = /* istanbul ignore next */(0, _reactAddonsTestUtils.findRenderedDOMComponentWithTag)(container, 'input');
    expect(textField.value).toBe(stringValue);

    container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)(
    /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, /* istanbul ignore next */{ id: 'test', defaultValue: null, locales: 'en-US', DateTimeFormat: DateTimeFormat }));


    textField = /* istanbul ignore next */(0, _reactAddonsTestUtils.findRenderedDOMComponentWithTag)(container, 'input');
    expect(textField.value).toBe('');
  });

  it('when the ok button is clicked, the onChange prop is called with the formatted date string, the new date object, and the event', function () {
    var defaultValue = '3/17/2016';
    var DateTimeFormat = jest.fn(function () /* istanbul ignore next */{return { format: function /* istanbul ignore next */format() /* istanbul ignore next */{return defaultValue;} };});
    var event = { target: 'a' };
    var onChange = jest.fn();
    var container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)(
    /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, /* istanbul ignore next */{
      id: 'test',
      locales: 'en-US',
      onChange: onChange,
      defaultValue: defaultValue,
      DateTimeFormat: DateTimeFormat }));



    container._handleOkClick(event);
    expect(onChange.mock.calls.length).toBe(1);
    expect(onChange.mock.calls[0][0]).toBe(defaultValue);
    expect(onChange.mock.calls[0][1]).toEqual(new Date(defaultValue));
    expect(onChange.mock.calls[0][2]).toEqual(event);
  });

  it('calls the onChange prop with the new formatted date string and the new date object when the autoOk prop is true and a new date is selected.', function () {
    var onChange = jest.fn();
    var defaultValue = '3/17/2016';
    var DateTimeFormat = jest.fn(function () /* istanbul ignore next */{return { format: function /* istanbul ignore next */format() /* istanbul ignore next */{return defaultValue;} };});

    var container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)(
    /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, /* istanbul ignore next */{
      id: 'test',
      locales: 'en-US',
      onChange: onChange,
      defaultValue: defaultValue,
      DateTimeFormat: DateTimeFormat }));



    var tempDate = new Date(2016, 2, 15);
    container._setCalendarTempDate(tempDate);
    expect(onChange.mock.calls.length).toBe(0);
    expect(container.state.calendarTempDate).toEqual(tempDate);

    container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)(
    /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, /* istanbul ignore next */{
      id: 'test',
      locales: 'en-US',
      onChange: onChange,
      defaultValue: defaultValue,
      DateTimeFormat: DateTimeFormat,
      autoOk: /* istanbul ignore next */true }));



    tempDate = new Date(2016, 2, 18);
    container._setCalendarTempDate(tempDate);
    expect(onChange.mock.calls.length).toBe(1);
    expect(container.state.calendarTempDate).toEqual(tempDate);
    expect(onChange.mock.calls[0][0]).toBe(defaultValue);
    expect(onChange.mock.calls[0][1]).toEqual(tempDate);
  });

  it('allows for an initial calendar date as a string', function () {
    var initialCalendarDateStr = '3/17/2016';
    var initialCalendarDate = new Date(initialCalendarDateStr);
    var props = {
      locales: 'en-US',
      initialCalendarDate: initialCalendarDateStr,
      id: 'test' };


    var container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)( /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, props));

    expect(container.state.calendarDate).toEqual(initialCalendarDate);
    expect(container.state.calendarTempDate).toEqual(initialCalendarDate);
  });

  it('allows for an initial calendar date as a Date object', function () {
    var initialCalendarDate = new Date(2016, 2, 18);
    var props = { locales: 'en-US', initialCalendarDate: initialCalendarDate, id: 'test' };

    var container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)( /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, props));

    expect(container.state.calendarDate).toEqual(initialCalendarDate);
    expect(container.state.calendarTempDate).toEqual(initialCalendarDate);
  });

  it('modifies the initial state\'s calendarDate if the min date is greater than the calendarDate', function () {
    var minDate = new Date();
    minDate.setDate(minDate.getDate() + 2);

    var props = { minDate: minDate, locales: 'en-US', id: 'test' };
    var container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)( /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, props));

    expect(container.state.calendarDate).toEqual(minDate);
    expect(container.state.calendarTempDate).toEqual(minDate);
  });

  it('modifies the initial state\'s calendarDate if the max date is less than the calendarDate', function () {
    var maxDate = new Date();
    maxDate.setDate(maxDate.getDate() - 2);

    var props = { maxDate: maxDate, locales: 'en-US', id: 'test' };
    var container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)( /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, props));

    expect(container.state.calendarDate).toEqual(maxDate);
    expect(container.state.calendarTempDate).toEqual(maxDate);
  });

  it('should not open the DatePicker if it is disabled and the text field is clicked', function () {
    var props = { id: 'test', disabled: true };
    var container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)( /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, props));

    container._toggleOpen({ target: { tagName: 'input' } });
    expect(container.state.visible).toBe(false);
  });

  it('should not open the DatePicker if it is disabled and the users pressed the enter key while focused on the keyboard', function () {
    var props = { id: 'test', disabled: true };
    var container = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)( /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, props));

    container._handleKeyDown({ keyCode: /* istanbul ignore next */_keyCodes.ENTER, target: { tagName: 'input' } });
    expect(container.state.visible).toBe(false);
  });

  describe('validateDateRange', function () {
    var picker = /* istanbul ignore next */(0, _reactAddonsTestUtils.renderIntoDocument)( /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_DatePickerContainer2.default, /* istanbul ignore next */{ id: 'validate-date-range-test' }));
    it('should return the date if there is no min or max date', function () {
      var date = new Date(2016, 0);
      expect(picker._validateDateRange(date)).toEqual(date);
    });

    it('should return the date if it is greater than the min date and there is no max date', function () {
      var date = new Date(2016, 0);
      var min = new Date(2000, 0);
      expect(picker._validateDateRange(date, min)).toEqual(date);
    });

    it('should return the date if it is less than the max date and there is no min date', function () {
      var date = new Date(2016, 0);
      var min = null;
      var max = new Date(2020, 0);
      expect(picker._validateDateRange(date, min, max)).toEqual(date);
    });

    it('should return the date if it is between the min and max date', function () {
      var date = new Date(2016, 0);
      var min = new Date(2000, 0);
      var max = new Date(2020, 0);
      expect(picker._validateDateRange(date, min, max)).toEqual(date);
    });

    it('should return the min date if it is less than the min date', function () {
      var date = new Date(1016, 0);
      var min = new Date(2000, 0);
      var max = new Date(2020, 0);
      expect(picker._validateDateRange(date, min, max)).toEqual(min);
    });

    it('should return the max date if it is greater than the max date', function () {
      var date = new Date(3016, 0);
      var min = new Date(2000, 0);
      var max = new Date(2020, 0);
      expect(picker._validateDateRange(date, min, max)).toEqual(max);
    });
  });
});